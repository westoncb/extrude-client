To credit for DDZ/Ratamahatta: https://web.archive.org/web/20000303203827/http://www.planetquake.com:80/polycount/cottages/evilb/quake.htm (brian collins aka Brian “EvilBastard” Collins’)

Movement should feel like super mario world

Network behavior:
    - Update local simulation from local keypresses immediately
    - Treat server-relayed keypresses as if they were additional local character actions: simulate on reception
    - However, if the action is time-extended, between e.g. keydown and keyup, then it should be re-simulated on reception of the closing action. This can be done by using a second copy of the gameloop/update cycle that's detached from rendering/no frame-pause--it just computes game states from a starting state and either A) a list of input events, or B) a function that maps time -> input device state...
    - Alternatively (this seems better), clients can send the affected state deltas whenever a time-extended event completes, the server relays it, and the clients just merge the delta into their own local state (server does this too actually).
    More explicitly:
        All input events whether local or remote are handled identically. When a 'completing' event (e.g. "key up") occurs, check if the player its associated to is the local player, if so: emit a "state_override" event with the entire object(s) affected by the time-extended event that just completed.
        
        This means all clients run the same simulation in parallel, but each client is authoratative with respect to its own time-extended events. This is because maintaining the intrinsic structure of time-extended events is important and 1) other clients can distort that structure because of network delays, and 2) non-time-extended events have no intrinsic structure. This does however still allow for latency-related distortions of the relations between objects belonging to different clients. But that should be fine since this app doesn't require tight synchronization of events between players--it's only coherence of a single player's own events that matters.
    - The server also needs to relay the complete state to incoming players however. If we don't want to simulate on the server, the server can request the full state from an already connected client and then relay that to the incoming client.

3rd person camera
Always show 'laser pointer' based on mouse position projected onto ground or other objects. Character faces laser dot, camera looks at character from behind

Laser pointer location is used to draw polygons that can be extruded. Polygon drawing should be guided to snap lines.

Controls:
    Shift click to select polygon surrounding surface beneath laser (for, e.g., going back to an extruded surface and extruding the whole thing some more)

Snap lines:
    Directions orthogonal to other lines in polygon


SSAOPass example: https://codesandbox.io/s/react-three-fiber-blob-qv9ww?from-embed
Webcam image capture example: https://googlechrome.github.io/samples/image-capture/photo-resolution.html
Heroku server repo: https://git.heroku.com/nameless-depths-23573.git